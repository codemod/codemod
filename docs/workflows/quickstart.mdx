---
title: "Quickstart"
description: "Create your first Codemod package and run it locally."
---

A **Codemod package** is a set of files that define an automated code transformation. Codemod Packages let you create, test, and distribute reusable transformations that update source code across entire codebases.

Packages range from quick, single-file refactors to advanced, multi-step migrations. They're fully portable—run them locally, in CI, or share with your team.

import { PackagesDemo } from "/snippets/packages-demo.mdx";

<Frame>
    <PackagesDemo />
</Frame>

<Steps>
  <Step title="Create a new Codemod package">

    Scaffold a new Codemod package:

    ```bash
    npx codemod init
    ```

    Each package includes your transformation logic (written in JavaScript, TypeScript, or YAML), a project manifest, and [workflow](/workflows/building-workflows) specification.

    When creating a new codemod project, you'll be prompted for:

    - **Project directory**
    - **Codemod type:**
      - <Tooltip tip="Best for simple code transformations. Uses the JavaScript ast-grep engine.">JavaScript ast-grep (jssg) codemod</Tooltip>
      - <Tooltip tip="Best for orchestrating large-scale migration campaigns. Combines shell commands, YAML ast-grep rules, and JS codemods into a single workflow.">Multi-step workflow (shell command, YAML & jssg)</Tooltip>
    - **Target language**
    - **Project name**
    - **Description**
    - **Author**
    - **License type**
    - **If your codemod is private**

    This creates a new folder with the required files and structure.
  </Step>

  <Step title="Explore the generated project">
    An example Codemod package:

    ```plaintext
    example-codemod/
    ├── .gitignore
    ├── README.md
    ├── codemod.yaml        #  manifest and metadata
    ├── workflow.yaml       # Workflow definition for running the codemod
    ├── scripts/            # JS/TS codemods and shell scripts
    │   └── codemod.ts      # JS ast-grep codemod entry point
    └── rules/              # YAML ast-grep rule definitions
        └── config.yml
    ```

    <Info>
      You can combine different codemod types in a single package. The <code>scripts/</code> and <code>rules/</code> folders are conventional, not required—use any paths you prefer as long as you reference them correctly from <code>workflow.yaml</code>.
    </Info>

    Check out the [Codemod package structure](/workflows/building-workflows) for more details.
  </Step>

  <Step title="Understand an example workflow">
    The generated <code>workflow.yaml</code> will differ depending on the codemod type you select:

    ```yaml Comprehensive workflow with all 5 step types: jssg, ai, yaml, registry, shell
    version: "1"
    nodes:
      - id: migrate-analytics
        name: Migrate legacy analytics to analytics.track({ event, properties })
        type: automatic
        steps:
          # 1) Codemod Registry: do the broad, well-defined baseline migration first
          - name: "Run registry codemod: legacy analytics -> analytics.track"
            codemod:
              source: "@codemod/migrate-analytics-v2"
              args:
                - "legacy-analytics"
                - "analytics-v2"

          # 2) JS ast-grep (jssg): handle higher-signal project-specific patterns
          - name: "Project-specific TS codemod (wrappers + key normalization)"
            js-ast-grep:
              js_file: "scripts/codemods/migrate-analytics-wrappers.ts"
              language: "typescript"
              include:
                - "src/**/*.{ts,tsx}"
              exclude:
                - "**/*.test.ts"

          # 3) AI step: transform the hard cases the rules miss
          - name: "AI fixups: dynamic calls + edge cases -> analytics.track object form"
            ai:
              prompt: |
                You are performing a code migration. Modify files directly.

                Goal:
                Convert any remaining legacy analytics calls into:
                  analytics.track({ event: <string>, properties: <object> })

                Handle these hard cases:
                1) Dynamic event names: trackEvent(getName(), props)
                  - Preserve semantics. event should become getName().
                2) Non-object props: trackEvent("X", foo)
                  - Convert to properties: foo if foo is object-like, otherwise { value: foo }.

                Constraints:
                - Keep formatting roughly intact (prettier will run later).
                - If you are unsure about a transformation, add a TODO comment right above it explaining why.

          # 4) YAML ast-grep: clean up simple leftovers consistently (fast + deterministic)
          - name: "Apply cleanup rules (YAML ast-grep)"
            ast-grep:
              config_file: "rules/analytics_cleanup.yml"
              include:
                - "src/**/*.{ts,tsx,js,jsx}"
              exclude:
                - "**/*.test.*"

          # 5) Shell command: format after all transformations
          - name: "Format code"
            run: npx prettier --write "src/**/*.{ts,tsx,js,jsx}"
    ```

    Learn more about building workflows [here](/workflows/building-workflows).
  </Step>

  <Step title="Validate & run your Codemod package">
    ```bash
    npx codemod workflow validate -w workflow.yaml
    npx codemod workflow run -w workflow.yaml
    ```

    This will check your workflow for errors and then run it locally.

    <Info>
      The <code>workflow validate</code> command checks syntax and schema compliance, but not logical correctness. Always test with real data to ensure expected behavior.
    </Info>
  </Step>
</Steps>
