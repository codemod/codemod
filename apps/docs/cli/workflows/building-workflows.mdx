---
title: "Building workflows"
---

## Workflow File

```yaml workflow.yaml
version: "1"
state:
  schema: []
templates: []
nodes: []
```

A workflow has four top-level keys:

| Key                       | Required | Purpose                                           |
| ------------------------- | -------- | ------------------------------------------------- |
| `version`                 | ✓        | Declare workflow schema version (default: `"1"`). |
| [`state`](#shared-state)  |          | Declares shared-state schema.                     |
| [`templates`](#templates) |          | Re-usable blocks.                                 |
| [`nodes`](#nodes)         | ✓        | Executable DAG.                                   |

---

## Shared State

```yaml
version: "1"
state:
  schema:
    - name: shards
      type: array
      items:
        type: object
        properties:
          team:    { type: string }
          shardId: { type: string }
nodes: []
```

---

## Templates

```yaml
version: "1"
templates:
  - id: checkout-repo
    name: Checkout Repository
    inputs:
      - name: repo_url
        type: string
        required: true
    steps:
      - name: Clone
        run: git clone ${{inputs.repo_url}} repo
```

**Template Inputs & Usage**:

Templates can define required or optional inputs, which are referenced in their steps.

<Info>
  Template steps are supported. Use the <code>use</code> key inside a step to call a template with inputs.
</Info>

---

## Nodes & Steps

Nodes are execution units in your workflow. They can be automatic or manual, depend on other nodes, and may define strategy (e.g., matrix), trigger, runtime, env, and an ordered list of steps. Steps are the atomic actions inside a node; they run sequentially and each step performs one action (`run`, `use`, `ast-grep`, `js-ast-grep`, `codemod`, or `ai`).

### Nodes

```yaml
version: "1"
nodes:
  - id: build
    name: Build
    type: automatic
    steps:
      - name: npm install
        run: npm ci
```

<ParamField path="id" type="string" required>
  Unique within the workflow.
</ParamField>

<ParamField path="name" type="string" required>
  Display name.
</ParamField>

<ParamField path="type" type="string" required>
  `automatic` (default) or `manual`.
</ParamField>

<ParamField path="depends_on" type="string[]">
  Upstream node IDs.
</ParamField>

<ParamField path="trigger" type="object">
  `{ type: manual }` → approval gate.
</ParamField>

<ParamField path="strategy" type="object">
  Matrix configuration.
</ParamField>

<ParamField path="steps" type="array" required>
  Ordered list of steps.
</ParamField>

<ParamField path="runtime" type="object">
  Container/runtime configuration (e.g., Docker).
</ParamField>

<ParamField path="env" type="object">
  Environment variables for the node or step.
</ParamField>

### Step

<Tabs>
  <Tab title="Shell command step">
    Runs shell commands on the host. Use for setup/cleanup, invoking external tools, or glue logic between transformations.
    ```yaml
    steps:
      - name: Install dependencies
        run: |
          npm install
          npm run build
    ```

    <ParamField path="name" type="string" required>
    Step label.
    </ParamField>

    <ParamField path="run" type="string">
    Inline shell command to execute.

    Provide either <code>run</code> or <code>use</code>, not both.
    </ParamField>
  </Tab>

  <Tab title="Template step">
    Invokes a reusable template by ID with inputs. Use to standardize common sequences across nodes/workflows.

    ```yaml
    steps:
      - name: Checkout Repository
        use:
          template: checkout-repo
          inputs:
            repo_url: "https://github.com/org/repo.git"
    ```

    <ParamField path="use.template" type="string" required>
    Template ID to invoke.
    </ParamField>

    <ParamField path="use.inputs" type="object">
    Key-value inputs passed to the template.
    </ParamField>
  </Tab>

  <Tab title="YAML ast-grep step">
    Executes ast-grep using a YAML config. Use for fast, declarative pattern matching and structured find/replace.
    ```yaml
    steps:
      - name: Apply ast-grep rules
        ast-grep:
          config_file: "rules/config.yml"
          base_path: "./src"
          include:
            - "**/*.js"
          exclude:
            - "**/*.test.js"
    ```

    <ParamField path="ast-grep.config_file" type="string" required>
      Path to the ast-grep configuration file (.yaml).
    </ParamField>

    <ParamField path="ast-grep.include" type="string[]">
      Include glob patterns.
    </ParamField>

    <ParamField path="ast-grep.exclude" type="string[]">
      Exclude glob patterns.
    </ParamField>

    <ParamField path="ast-grep.base_path" type="string">
      Base path for resolving globs.
    </ParamField>

    <ParamField path="ast-grep.max_threads" type="number">
      Maximum concurrent threads.
    </ParamField>

  </Tab>

  <Tab title="JS ast-grep (jssg) step">
    Runs a TypeScript/JavaScript codemod powered by ast-grep. Use when you need programmatic logic beyond YAML rules.
    ```yaml
    steps:
      - name: Run jssg codemod
        js-ast-grep:
          js_file: "scripts/codemod.ts"
          base_path: "."
          language: "typescript"
          include:
            - "**/*.ts"
            - "**/*.tsx"
    ```

    <ParamField path="js-ast-grep.js_file" type="string" required>
      Path to the JS/TS file that implements the codemod.
    </ParamField>

    <ParamField path="js-ast-grep.language" type="string">
      Target language (e.g., <code>typescript</code>, <code>javascript</code>, etc.).
    </ParamField>

    <ParamField path="js-ast-grep.include" type="string[]">
      Include glob patterns.
    </ParamField>

    <ParamField path="js-ast-grep.exclude" type="string[]">
      Exclude glob patterns.
    </ParamField>

    <ParamField path="js-ast-grep.base_path" type="string">
      Base path for resolving globs.
    </ParamField>

    <ParamField path="js-ast-grep.max_threads" type="number">
      Maximum concurrent threads.
    </ParamField>

    <ParamField path="js-ast-grep.dry_run" type="boolean" default="false">
      Perform a dry run without applying changes.
    </ParamField>
  </Tab>

  <Tab title="Codemod Registry step">
    Runs another codemod by package name (or local path). Use to compose larger migrations by chaining codemods.
    ```yaml
    steps:
      - name: Run registry codemod
        codemod:
          source: "@scope/package@1.2.3"
          args: ["--flag", "value"]
          env:
            NODE_ENV: production
          working_dir: "."
    ```

    <ParamField path="codemod.source" type="string" required>
      Codemod source (registry package or local path).
    </ParamField>

    <ParamField path="codemod.args" type="string[]">
      CLI arguments passed to the codemod.
    </ParamField>

    <ParamField path="codemod.env" type="object">
      Environment variables used during execution.
    </ParamField>

    <ParamField path="codemod.working_dir" type="string">
      Working directory for execution.
    </ParamField>
  </Tab>

  <Tab title="AI step">
    Calls an AI agent with a prompt. Use for generating change plans or reviews; validate outputs and prefer dry runs in critical paths.
    ```yaml
    steps:
      - name: Review diffs with AI
        ai:
          prompt: |
            Summarize risky changes and suggest tests.
          model: "gpt-4o"
    ```

    <ParamField path="ai.prompt" type="string" required>
      Prompt to send to the AI agent.
    </ParamField>

   <ParamField path="ai.model" type="string" default="gpt-4o">
     Model identifier. Overrides <code>LLM_MODEL</code> if set.
   </ParamField>

    <ParamField path="ai.env" type="object">
      Environment variables used during execution.
    </ParamField>

    <ParamField path="ai.dry_run" type="boolean" default="false">
      Perform a dry run.
    </ParamField>

    <ParamField path="ai.system_prompt" type="string">
      System prompt to scope the AI agent’s behavior.
    </ParamField>

   <ParamField path="ai.max_steps" type="number" default="30">
    Maximum number of agent steps before stopping.
    </ParamField>

    <ParamField path="ai.enable_lakeview" type="boolean" default="false">
      Enables lakeview mode for agent outputs.
    </ParamField>

    <ParamField path="ai.llm_protocol" type="string" default="openai">
      LLM provider/protocol. Supported: <code>openai</code>, <code>anthropic</code>, <code>google_ai</code>, <code>azure_openai</code>.
    </ParamField>

    <ParamField path="ai.endpoint" type="string">
      LLM base URL. If omitted, defaults to the provider’s standard endpoint.
    </ParamField>

    <ParamField path="ai.api_key" type="string">
      API key to access the LLM. Prefer <code>LLM_API_KEY</code> env var instead of hardcoding here.
    </ParamField>

    <Info>
      The AI step requires valid LLM credentials. Provide them via environment variables or inline on the step.
    </Info>

    **Option A — Environment variables (recommended)**

    ```bash
    LLM_API_KEY=YOUR_KEY
    LLM_PROVIDER=openai
    LLM_MODEL=gpt-4o
    LLM_BASE_URL=https://api.openai.com/v1
    ```

    **Option B — Inline on the AI step**

    ```yaml
    steps:
      - name: Review diffs with AI
        ai:
          prompt: |
            Summarize risky changes and suggest tests.
          llm_protocol: "openai"                    # provider
          endpoint: "https://api.openai.com/v1"     # base URL
          model: "gpt-4o"                           # model
          api_key: "YOUR_KEY"                        # paste key inline
    ```

    <Warning>
      Avoid hardcoding secrets in YAML. Prefer environment variables and CI secret stores.
    </Warning>

    <Note>
      The <code>ai.api_key</code> field does not support expression interpolation. It must be a literal string. To use environment variables, set <code>LLM_API_KEY</code> in your shell and omit <code>ai.api_key</code>.
    </Note>
  </Tab>
</Tabs>

## Matrix Strategy

```yaml
version: "1"
state:
  schema:
    - name: shards
      type: array
      items:
        type: object
        properties:
          team: { type: string }
          shardId: { type: string }
nodes:
  - id: matrix-codemod
    name: Matrix Codemod
    strategy:
      type: matrix
      from_state: shards
    steps:
      - name: Codemod
        run: node codemod.js --team=$team --shard=$shardId
```

<Accordion title="Dynamic Matrix Task Recompilation">
  When the array referenced by `from_state` changes, Codemod CLI:

  1. Creates new tasks for new items.
  2. Marks tasks as `WontDo` if their item is removed.
  3. Leaves existing tasks untouched if their item remains.

  <Info>
    Matrix nodes have a **master task** that tracks the status of all generated tasks.
  </Info>
</Accordion>

---

## Manual Trigger

```yaml
version: "1"
nodes:
  - id: manual-approval
    name: Manual Approval
    trigger:
      type: manual
    steps:
      - name: Wait for approval
        run: echo "Waiting for manual approval"
```

<Accordion title="Task UUIDs & Resume">
  Manual tasks are assigned unique UUIDs. You can resume:

  - All paused tasks:

    ```bash
    npx codemod workflow resume -i <run-id> --trigger-all
    ```
  - A specific task:

    ```bash
    npx codemod workflow resume -i <run-id> -t <task-uuid>
    ```
</Accordion>

---

## State Updates

| Syntax       | Meaning                            | Example                                 |
| ------------ | ---------------------------------- | --------------------------------------- |
| `KEY=VAL`    | Set state key to value             | `count=10`                              |
| `KEY@=VAL`   | Append value to array at state key | `shards@={"team":"core","shardId":"1"}` |
| Dot notation | Set nested state fields            | `config.retries=5`                      |
| JSON values  | Use valid JSON for objects/arrays  | `user={"name":"Alice","id":123}`        |

<Info>
  All state updates must be valid JSON if not a primitive. Updates are applied only if the task exits successfully.
</Info>

<AccordionGroup>
  <Accordion title="Container Runtimes">
    Planned feature: containerized execution (e.g., Docker/Podman). Currently, workflows run in the host shell. When available, you'll be able to specify a runtime per node or template.
  </Accordion>
  <Accordion title="State Management & Persistence">
    <Info>
      Workflow state is persisted after every task. If interrupted, you can resume from the last saved state—no work is lost.
    </Info>
  </Accordion>
  <Accordion title="Matrix Master Task">
    For matrix nodes, a master task aggregates the status of all generated tasks.\
    If all child tasks complete, the master is `Completed`. If any fail, the master is `Failed`.
  </Accordion>
  <Accordion title="Cyclic Dependency Example">
    If your workflow has a cycle:

    ```yaml
    nodes:
      - id: a
        name: Task A
        depends_on: [b]
        steps:
          - name: Task A
            run: echo "Task A"
      - id: b
        name: Task B
        depends_on: [a]
        steps:
          - name: Task B
            run: echo "Task B"
    ```

    You'll see:

    ```bash
    ✗ Workflow definition is invalid
    Error: Cyclic dependency detected: a → b → a
    ```

    <Info>
      This error is shown when you run `npx codemod workflow validate` or `npx codemod workflow run` on a workflow with a cyclic dependency.
    </Info>
  </Accordion>
</AccordionGroup>

---

## Task Statuses

<ResponseField name="Pending">
  Queued; waiting for runner.
</ResponseField>

<ResponseField name="Running">
  Currently executing.
</ResponseField>

<ResponseField name="Completed">
  Succeeded; diff applied.
</ResponseField>

<ResponseField name="Failed">
  Script exited non-zero; diff discarded.
</ResponseField>

<ResponseField name="AwaitingTrigger">
  Waiting for manual approval.
</ResponseField>

<ResponseField name="Blocked">
  Dependencies not finished.
</ResponseField>

<ResponseField name="WontDo">
  Matrix item removed; task skipped.
</ResponseField>

## Variable Resolution

- **Parameter:** `${{params.branch}}` — Supplied at runtime
- **Environment:** `${{env.CI}}` — Host env var
- **Shared State:** `${{state.counter}}` — Live JSON value

<Info>
  In matrix tasks, each object key becomes an environment variable (e.g., `$team`, `$shardId`, …).
</Info>

---

## Roadmap

<Steps>
  <Step title="Container runtime support" icon="flag-pennant">
    Support for `runtime: docker` and other container runtimes, allowing tasks to run in isolated environments.
  </Step>
  <Step title="Nested matrix strategies" icon="flag-pennant">
    Support for matrix strategies within matrix strategies, enabling more complex task fan-out.
  </Step>
</Steps>

## Next Steps

<CardGroup cols={2}>
  <Card title="Codemod CLI Reference" icon="terminal" href="/cli/cli-reference">
    Explore the full command and option reference for Codemod CLI.
  </Card>
  <Card title="Build Workflows with Codemod MCP" icon="robot" href="/mcp">
    Learn how to build codemod workflows in your IDE using Codemod MCP.
  </Card>
</CardGroup>
