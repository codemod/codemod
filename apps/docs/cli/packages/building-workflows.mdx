---
title: "Building workflows"
---

This page explains the concepts and structure of the Codemod package's workflow file.

<Tip>
  This is an advanced topic. If you're just getting started, we recommend using [Codemod Studio](/codemod-studio) or [Codemod MCP](/cli/mcp) to create your codemod package with the help of AI.
</Tip>

## Workflow File

A workflow has four top-level keys:

```yaml workflow.yaml
version: "1"
state:
  schema: []
templates: []
nodes: []
```

| Key                       | Required | Purpose                                           |
| ------------------------- | -------- | ------------------------------------------------- |
| `version`                 | ✓        | Declare workflow schema version (default: `"1"`). |
| [`state`](#shared-state)  |          | Declares shared-state schema.                     |
| [`templates`](#templates) |          | Re-usable blocks.                                 |
| [`nodes`](#nodes)         | ✓        | Executable DAG.                                   |

---

## Shared State

```yaml
version: "1"
state:
  schema:
    - name: shards
      type: array
      items:
        type: object
        properties:
          team:    { type: string }
          shardId: { type: string }
nodes: []
```

You can also declare state schema using an object map:

  ```yaml
  version: "1"
  state:
    schema:
      shards:
        type: array
        items:
          type: object
          properties:
            team:    { type: string }
            shardId: { type: string }
  nodes: []
  ```

---

## Nodes & Steps

### Nodes

Nodes are execution units in your workflow. They can be automatic or manual, depend on other nodes, and may define strategy (e.g., matrix), trigger, runtime, env, and an ordered list of steps.

```yaml
version: "1"
nodes:
  - id: build
    name: Build
    type: automatic
    steps:
      - name: npm install
        run: npm ci
```

<ParamField path="id" type="string" required>
  Unique within the workflow.
</ParamField>

<ParamField path="name" type="string" required>
  Display name.
</ParamField>

<ParamField path="type" type="string">
  `automatic` (default) or `manual`.
</ParamField>

<ParamField path="depends_on" type="string[]">
  Upstream node IDs. Learn more about cyclic dependencies [here](#cyclic-dependency-example).
</ParamField>

<ParamField path="trigger" type="object">
  `{ type: manual }` → approval gate. Learn more about manual triggers [here](#manual-trigger).
</ParamField>

<ParamField path="strategy" type="object">
  Matrix configuration. Learn more about matrix strategies [here](#matrix-strategy).
</ParamField>

<ParamField path="steps" type="array" required>
  Ordered list of [steps](#step).
</ParamField>

<ParamField path="env" type="object">
  Environment variables for the node or step.
</ParamField>

### Step

Steps are the atomic actions inside a node; they run sequentially and each step performs one action 
- [`run`](#shell-command-step)
- [`ast-grep`](#yaml-ast-grep-step)
- [`js-ast-grep`](#js-ast-grep-step)
- [`codemod`](#codemod-registry-step)
- [`ai`](#ai-step)

All step types support the following field:

<ParamField path="if" type="string">
    Conditional expression to gate the step. `if` is evaluated before executing any step type.
    
    Expression evaluation supports referencing `params.x` and `state.x`, and any matrix value keys (injected as-is). Supported operators include `==`, `!=`, `>`, `<`, `&&`, and `||`.

    Example: `params.autoAIReview`.
    
    See [Variable resolution](#variable-resolution) for the full expression and interpolation grammar.
  </ParamField>



<AccordionGroup>

  <Accordion title="Shell command step">
    Runs shell commands on the host. Use for setup/cleanup, invoking external tools, or glue logic between transformations.
    ```yaml
    steps:
      - name: Install dependencies
        run: |
          npm install
          npm run build
    ```

    <ParamField path="name" type="string" required>
      Step label.
    </ParamField>

    <ParamField path="run" type="string">
      Inline shell command to execute.
    </ParamField>

    <ParamField path="env" type="object">
      Step-level environment variables applied to the process environment for this `run` step.
    </ParamField>
  </Accordion>



  <Accordion title="YAML ast-grep step">
    Executes ast-grep using a YAML config. Use for fast, declarative pattern matching and structured find/replace.
    ```yaml
    steps:
      - name: Apply ast-grep rules
        ast-grep:
          config_file: "rules/config.yml"
          base_path: "./src"
          include:
            - "**/*.js"
          exclude:
            - "**/*.test.js"
    ```

    <ParamField path="ast-grep.config_file" type="string" required>
      Path to the ast-grep configuration file (.yaml).
    </ParamField>

    <ParamField path="ast-grep.include" type="string[]">
      Include glob patterns.
    </ParamField>

    <ParamField path="ast-grep.exclude" type="string[]">
      Exclude glob patterns.
    </ParamField>

    <ParamField path="ast-grep.base_path" type="string">
      Base path for resolving globs.
    </ParamField>

    <ParamField path="ast-grep.max_threads" type="number">
      Maximum concurrent threads.
    </ParamField>
  </Accordion>

  <Accordion title="JS ast-grep (jssg) step">
    Runs a TypeScript/JavaScript codemod powered by ast-grep. Use when you need programmatic logic beyond YAML rules.
    
    <Tip>
      New to jssg? Start with the <a href="/guides/jssg/quickstart">jssg quickstart</a> to scaffold a package and write your first transform.
    </Tip>
    ```yaml
    steps:
      - name: Run jssg codemod
        js-ast-grep:
          js_file: "scripts/codemod.ts"
          base_path: "."
          language: "typescript"
          include:
            - "**/*.ts"
            - "**/*.tsx"
    ```

    <ParamField path="js-ast-grep.js_file" type="string" required>
      Path to the JS/TS file that implements the codemod.
    </ParamField>

    <ParamField path="js-ast-grep.language" type="string">
      Target language (e.g., `typescript`, `javascript`, etc.).
    </ParamField>

    <ParamField path="js-ast-grep.include" type="string[]">
      Include glob patterns.
    </ParamField>

    <ParamField path="js-ast-grep.exclude" type="string[]">
      Exclude glob patterns.
    </ParamField>

    <ParamField path="js-ast-grep.base_path" type="string">
      Base path for resolving globs.
    </ParamField>

    <ParamField path="js-ast-grep.max_threads" type="number">
      Maximum concurrent threads.
    </ParamField>

    <ParamField path="js-ast-grep.dry_run" type="boolean" default="false">
      Perform a dry run without applying changes.
    </ParamField>
  </Accordion>

  <Accordion title="Codemod Registry step">
    Runs another codemod by package name (or local path). Use to compose larger migrations by chaining codemods.
    ```yaml
    steps:
      - name: Run registry codemod
        codemod:
          source: "@scope/package"
          args: ["--flag", "value"]
          env:
            NODE_ENV: production
          working_dir: "."
    ```

    <ParamField path="codemod.source" type="string" required>
      Codemod source (registry package or local path).

      <Tip>
        <b>Version pinning</b>: specify an exact version in <code>source</code> (e.g., <code>@scope/pkg@1.2.3</code>) for reproducible runs. If you omit the version, the latest published version is used.
      </Tip>
    </ParamField>

    <ParamField path="codemod.args" type="string[]">
      CLI arguments passed to the codemod.
    </ParamField>

    <ParamField path="codemod.env" type="object">
      Environment variables used during execution.
    </ParamField>

    <ParamField path="codemod.working_dir" type="string">
      Working directory for execution.
    </ParamField>

    <ParamField path="env" type="object">
      Step-level environment variables. For `codemod` steps, these are forwarded to the invoked workflow as parameters with an `env_` prefix (e.g., `FOO` → `env_FOO`). They are not applied to the OS environment of the nested workflow.
    </ParamField>

    **Aggregate multiple codemods:**

    <Info>
      You can <b>aggregate multiple codemods</b> by adding more than one <code>codemod</code> step in the same node. A codemod package may itself orchestrate other codemods, enabling nested compositions for larger upgrades.
    </Info>

    ```yaml
    steps:
      - name: Convert `createRequireFromPath` to `createRequire`
        codemod:
          source: "@nodejs/create-require-from-path"
      - name: Handle DEP0147 (`fs.rmdir` to `fs.rm`)
        codemod:
          source: "@nodejs/rmdir"
    ```

    <Info>
      - Steps in a node **run sequentially** from top to bottom.
      - Use [`depends_on`](#param-depends-on) or a matrix [`strategy`](#matrix-strategy) across multiple nodes for gating/parallelism.
      - If a step fails, the node fails and subsequent steps in that node are skipped.
    </Info>
  </Accordion>

  <Accordion title="AI step">
    Calls an AI agent with a prompt. Use for generating change plans or reviews; validate outputs and prefer dry runs in critical paths.
    ```yaml
    steps:
      - name: Review diffs with AI
        ai:
          prompt: |
            Summarize risky changes and suggest tests.
          model: "gpt-4o"
    ```

    <ParamField path="ai.prompt" type="string" required>
      Prompt to send to the AI agent.
    </ParamField>

    <ParamField path="ai.model" type="string" default="gpt-4o">
      Model identifier. Overrides `LLM_MODEL` if set.
    </ParamField>

    <ParamField path="ai.system_prompt" type="string">
      System prompt to scope the AI agent’s behavior.
    </ParamField>

    <ParamField path="ai.max_steps" type="number" default="30">
      Maximum number of agent steps before stopping.
    </ParamField>

    <ParamField path="ai.llm_protocol" type="string" default="openai">
      LLM provider/protocol. Supported: `openai`, `anthropic`, `azure_openai`.
    </ParamField>

    <ParamField path="ai.endpoint" type="string">
      LLM base URL. If omitted, defaults to the provider’s standard endpoint for the selected protocol. You can override with a custom endpoint.
    </ParamField>

    <ParamField path="ai.api_key" type="string">
      API key to access the LLM.
      
      **The AI step requires valid LLM credentials. Provide them via environment variables:**

      ```bash
      LLM_API_KEY=YOUR_KEY
      LLM_PROVIDER=openai
      LLM_MODEL=gpt-4o
      LLM_BASE_URL=https://api.openai.com/v1
      ```

      <Tip>
        LLM_BASE_URL is optional. If omitted, defaults to the provider’s standard endpoint for the selected protocol. You can override with a custom endpoint.
      </Tip>

    </ParamField>
  </Accordion>

</AccordionGroup>

## Matrix Strategy

```yaml
version: "1"
state:
  schema:
    - name: shards
      type: array
      items:
        type: object
        properties:
          team: { type: string }
          shardId: { type: string }
nodes:
  - id: matrix-codemod
    name: Matrix Codemod
    strategy:
      type: matrix
      from_state: shards
    steps:
      - name: Codemod
        run: node codemod.js --team=$team --shard=$shardId
```

<Accordion title="Dynamic Matrix Task Recompilation">
  When the array referenced by `from_state` changes, Codemod CLI:

  1. Creates new tasks for new items.
  2. Marks tasks as `WontDo` if their item is removed.
  3. Leaves existing tasks untouched if their item remains.

  <Info>
    Matrix nodes have a **master task** that tracks the status of all generated tasks.
  </Info>
</Accordion>

---

## Manual Trigger

```yaml
version: "1"
nodes:
  - id: manual-approval
    name: Manual Approval
    trigger:
      type: manual
    steps:
      - name: Wait for approval
        run: echo "Waiting for manual approval"
```

<Accordion title="Task UUIDs & Resume">
  Manual tasks are assigned unique UUIDs. You can resume:

  - All paused tasks:

    ```bash
    npx codemod workflow resume -i <run-id> --trigger-all
    ```
  - A specific task:

    ```bash
    npx codemod workflow resume -i <run-id> -t <task-uuid>
    ```
</Accordion>

---

## State Updates

| Syntax       | Meaning                            | Example                                 |
| ------------ | ---------------------------------- | --------------------------------------- |
| `KEY=VAL`    | Set state key to value             | `count=10`                              |
| `KEY@=VAL`   | Append value to array at state key | `shards@={"team":"core","shardId":"1"}` |
| Dot notation | Set nested state fields            | `config.retries=5`                      |
| JSON values  | Use valid JSON for objects/arrays  | `user={"name":"Alice","id":123}`        |

<Info>
  All state updates must be valid JSON if not a primitive. Updates are applied only if the task exits successfully.
</Info>

<AccordionGroup>
  <Accordion title="Container Runtimes">
    Planned feature: containerized execution (e.g., Docker/Podman). Currently, workflows run in the host shell. When available, you'll be able to specify a runtime per node or template.
  </Accordion>
  <Accordion title="State Management & Persistence">
    <Info>
      Workflow state is persisted after every task. If interrupted, you can resume from the last saved state—no work is lost.
    </Info>
  </Accordion>
  <Accordion title="Matrix Master Task">
    For matrix nodes, a master task aggregates the status of all generated tasks.\
    If all child tasks complete, the master is `Completed`. If any fail, the master is `Failed`.
  </Accordion>
  <Accordion title="Cyclic Dependency Example">
    If your workflow has a cycle:

    ```yaml
    nodes:
      - id: a
        name: Task A
        depends_on: [b]
        steps:
          - name: Task A
            run: echo "Task A"
      - id: b
        name: Task B
        depends_on: [a]
        steps:
          - name: Task B
            run: echo "Task B"
    ```

    You'll see:

    ```bash
    ✗ Workflow definition is invalid
    Error: Cyclic dependency detected: a → b → a
    ```

    <Info>
      This error is shown when you run `npx codemod workflow validate` or `npx codemod workflow run` on a workflow with a cyclic dependency.
    </Info>
  </Accordion>
</AccordionGroup>

---

## Task Statuses

<ResponseField name="Pending">
  Queued; waiting for runner.
</ResponseField>

<ResponseField name="Running">
  Currently executing.
</ResponseField>

<ResponseField name="Completed">
  Succeeded; diff applied.
</ResponseField>

<ResponseField name="Failed">
  Script exited non-zero; diff discarded.
</ResponseField>

<ResponseField name="AwaitingTrigger">
  Waiting for manual approval.
</ResponseField>

<ResponseField name="Blocked">
  Dependencies not finished.
</ResponseField>

<ResponseField name="WontDo">
  Matrix item removed; task skipped.
</ResponseField>

## Variable Resolution

- **Parameter:** `${{params.branch}}` — Supplied at runtime
- **Environment:** `${{env.CI}}` — Host env var
- **Shared State:** `${{state.counter}}` — Live JSON value

<Tip>
  - In matrix tasks, each object key becomes an environment variable (e.g., `$team`, `$shardId`, …). Inside steps, variables are unprefixed.

  - Operators (`==`, `!=`, `>`, `<`, `&&`, `||`) are supported inside string interpolations like `${{ ... }}` for resolving parameters, state, and matrix values.
</Tip>

---

## Roadmap

<Steps>
  <Step title="Container runtime support" icon="flag-pennant">
    Support for `runtime: docker` and other container runtimes, allowing tasks to run in isolated environments.
  </Step>
  <Step title="Nested matrix strategies" icon="flag-pennant">
    Support for matrix strategies within matrix strategies, enabling more complex task fan-out.
  </Step>
</Steps>

## Next Steps

<CardGroup cols={2}>
  <Card title="Codemod CLI Reference" icon="terminal" href="/cli/cli-reference">
    Explore the full command and option reference for Codemod CLI.
  </Card>
  <Card title="Build Workflows with Codemod MCP" icon="robot" href="/cli/mcp">
    Learn how to build codemod workflows in your IDE using Codemod MCP.
  </Card>
</CardGroup>
